{{~ func default_value(property)
   if ((get_type property) == "Date")
     ret "new Date().toISOString().split('.')[0]"
    end
   ret get_default_value property
end ~}}
const ref = Vue.ref;
const reactive = Vue.reactive;
const watchEffect = Vue.watchEffect;
{{~ for class in classes
  if class.is_root
    root = class
    break
  end 
end ~}}
const  app = Vue.createApp({
  template: `
  {{~ for property in root.child_references ~}}
    <{{ kebab_case property.class.name }}{{ if property.is_collection }}-list{{ end }} v-model="{{ camel_case root.name }}.{{ camel_case property.name }}"></{{ kebab_case property.class.name }}{{ if property.is_collection }}-list{{ end }}>
  {{~ end ~}}
  `,
  name: 'App',
  setup: function () {
    const {{ camel_case root.name }} = ref(null);
    {{~ if input ~}}
    {{ camel_case root.name }}.value = {{input}};
    {{~ else ~}}
    function saveToLocalStorage(newValue) {
        let minimized = JSON.stringify(newValue);
        let oldValue = localStorage.getItem('json');
        if (minimized != oldValue) {
          localStorage.setItem('json', minimized);
        }
    }
    function loadFromLocalStorage() {
      let json = localStorage.getItem('json');
      if (json) {
        {{ camel_case root.name }}.value = JSON.parse(json);
      }
    }
    loadFromLocalStorage();

    watchEffect(() => {
      saveToLocalStorage({{ camel_case root.name }}.value);
    });

    window.addEventListener('storage', loadFromLocalStorage);
    {{~ end ~}}
    return { {{ camel_case root.name }}  }
  },
});
{{~ for class in classes
  if class.is_root
    continue
  end
  ~}}
app.component('{{ kebab_case class.name }}-form', {
  template: `
  <li class="list-group-item text-start" v-if="deletable">
    <button type="button" class="btn btn-sm rounded-pill" @click="$emit('delete')">
      <span class="bi bi-trash" aria-hidden="true"></span> Delete
    </button>
  </li>
  {{~ for property in class.base_properties ~}}
  <li class="list-group-item text-start">
    <div class="col-12 d-flex justify-content-start form-floating">
      {{~ if property.built_in_type == "Bool" ~}}
      <div class="form-check">
        <label class="form-check-label">
        <input class="form-check-input" type="checkbox" 
        :checked="modelValue.{{ camel_case property.name }}"
        @change="update{{property.name}}">
        {{ to_words property.name }}
        </label>
      </div>
      {{~ else ~}}
      <input
      {{~ if property.built_in_type == "Int" ~}}
      type="number"
      {{~ else if property.built_in_type == "Float" ~}}
      type="number"
      step="0.1"
      {{~ else ~}}
      :type="checkDate(modelValue.{{ camel_case property.name }}) ? 'datetime-local' : 'text'"
      {{~ end ~}}
      class="form-control"
      :value="modelValue.{{ camel_case property.name }}"
      @input="update{{property.name}}"
      placeholder="{{ to_words property.name }}">
      <label>{{ to_words property.name }}</label>
      {{~ end ~}}
    </div>
  </li>
  {{~ end ~}}
  `,
  name: '{{ class.name }}Form',
  props: {
    modelValue: Object,
    deletable: Boolean
  },
  emits: ['update:modelValue', 'delete'],
  setup(props, context) {

    function checkDate(str) {
      const regexExp = /^(\d{4}-\d{2}-\d{2}T\d{2}:\d{2})$/gi;
      return regexExp.test(str);
    }
    {{~ for property in class.base_properties ~}}
    function update{{property.name}}(event) {
      {{~ if property.built_in_type == "Int" ~}}
      const value = parseInt(event.target.value);
      {{~ else if property.built_in_type == "Float" ~}}
      const value = parseFloat(event.target.value);
      {{~ else if property.built_in_type == "Bool" ~}}
      const value = event.target.checked;
      {{~ else ~}}
      const value = event.target.value;
      {{~ end ~}}
      context.emit('update:modelValue', { ...props.modelValue, {{ camel_case property.name }}: value })
    };
    {{~ end ~}}
    return {
      {{~ for property in class.base_properties ~}}
      update{{property.name}},
      {{~ end ~}}
      checkDate
    }
  }
});

app.component('{{ kebab_case class.name }}', {
  template: `
    <div class="col-12 mb-2" :key="idx">
      <div class="card"> 
        <{{ kebab_case class.name }}-form :modelValue="modelValue" @update:modelValue="update" :deletable="deletable" @delete="$emit('delete')"></{{ kebab_case class.name }}-form>
      </div>
      {{~ for property in class.child_references ~}}
        <div class="card ms-5 mt-2">
          <div class="mt-3">
            {{~ if property.is_collection ~}}
            <{{ kebab_case property.class.name }}-list :modelValue="modelValue.{{ camel_case property.name }}" @update:modelValue="update{{ property.name }}"></{{ kebab_case property.class.name }}-list>
            {{~ else ~}}
            <{{ kebab_case property.class.name }} :modelValue="modelValue.{{ camel_case property.name }}" @update:modelValue="update{{ property.name }}" :deletable="false"></{{ kebab_case property.class.name }}>
            {{~ end ~}}
          </div>
        </div>
      {{~ end ~}}
  </div>`,
  name: '{{ class.name }}',
  props: {
    modelValue: Object,
    deletable: Boolean
  },
  emits: ['update:modelValue', 'delete'],
  setup(props, context) {
    {{~ for property in class.child_references ~}}
    function update{{ property.name }}(value) {
      let newObject = {
        ...props.modelValue,
        {{ camel_case property.name }}: value
      };
      context.emit('update:modelValue', newObject);
    }
    {{~ end ~}}

    function update(newValue) {
      context.emit('update:modelValue', newValue);
    }
    return {
      {{~ for property in class.child_references ~}}
      update{{ property.name }},
      {{~ end ~}}
      update
    };
  }
});
app.component('{{ kebab_case class.name }}-list', {
  template: `
  <div class="accordion" id="{{ class.name.plural }}">
    <div class="accordion-item">
      <h2 class="accordion-header" id="{{ class.name.plural }}-headingOne">
        <button class="accordion-button" type="button" data-bs-toggle="collapse" :data-bs-target="'#'+accordionId" aria-expanded="true" :aria-controls="accordionId">
          <h5>{{ class.name.plural }}:</h5>
        </button>
      </h2>
      <!-- If {{ class.name }} has an identifier, then use it instead of idx as key! -->
      <div :id="accordionId" class="accordion-collapse collapse show" aria-labelledby="{{ class.name.plural }}-headingOne">
        <div class="accordion-body">
          <{{ kebab_case class.name }} v-for="(item, idx) in modelValue" :key="idx" :modelValue="item" @update:modelValue="updateItem(idx, $event)" :deletable="true" @delete="deleteItem(idx)" v-if="modelValue">
          </{{ kebab_case class.name }}>
          <div v-if="newItem != null">
            <div class="card">
              <{{ kebab_case class.name }}-form :modelValue="newItem" @update:modelValue="saveNewItem($event)" @canceled="cancelAdd"></{{ kebab_case class.name }}-form>
            </div>
          </div>
          <div class="d-flex">
            <button type="button" class="btn btn-sm rounded-pill" @click="addNewItem()">
              <span class="bi bi-plus" aria-hidden="true"></span> Add {{ to_words class.name }}
            </button>
          </div>
        </div>
      </div>
    </div>
  </div>`,
  name: '{{ class.name }}List',
  props: {
    modelValue: Array
  },
  emits: ['update:modelValue'],
  setup(props, context) {

    function deleteItem(idx) {
      if (confirm('Are you sure to delete this {{ camel_case (to_words class.name) }}?')) {
        context.emit('update:modelValue', props.modelValue.filter((item, i) => i !== idx));
      }
    }
    function updateItem(idx, item) {
      let newList = [...props.modelValue];
      newList[idx] = item;
      context.emit('update:modelValue', newList);
    }
    function addNewItem() {
      let newItem = {
        {{~ for property in class.json_properties ~}}
        {{ camel_case property.name }}: {{ default_value property }}{{if !for.last}},{{end}}
        {{~ end ~}}
      };
      saveNewItem(newItem);
    }
    function saveNewItem(item) {
      if (props.modelValue) {
        const items = [...props.modelValue];
        items.push(item);
        context.emit('update:modelValue', items)
      } else {
        context.emit('update:modelValue', [item])
      }
      newItem.value = null
    }

    const accordionId = randomToken();

    return {
      deleteItem,
      updateItem,
      addNewItem,
      accordionId
    };
  }
});
{{~ end ~}}

function randomToken() {
  let token = '';
  while (token.length < 8)
    token += Math.random().toString(36).substring(2);
  return `a${token.substring(0, 8)}`;
}

app.mount('#app');
