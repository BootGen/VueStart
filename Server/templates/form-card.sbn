const ref = Vue.ref;
const reactive = Vue.reactive;
const watchEffect = Vue.watchEffect;
{{~ for class in classes
  if class.is_root
    root = class
    break
  end 
end ~}}
const  app = Vue.createApp({
  template: `
  {{~ for property in root.properties
  if property.is_collection && property.class
  ~}}
    <{{ kebab_case property.class.name }}-list v-model="{{ camel_case root.name }}.{{ camel_case property.class.name.plural }}"></{{ kebab_case property.class.name }}-list>
{{~ end
  end ~}}
  `,
  name: 'App',
  setup: function () {
    const {{ camel_case root.name }} = ref(null);
    function saveToLocalStorage(newValue) {
        let minimized = JSON.stringify(newValue);
        let oldValue = localStorage.getItem('json');
        if (minimized != oldValue) {
          localStorage.setItem('json', minimized);
        }
    }
    function loadFromLocalStorage() {
      let json = localStorage.getItem('json');
      if (json) {
        {{ camel_case root.name }}.value = JSON.parse(json);
      }
    }

    loadFromLocalStorage();

    watchEffect(() => {
      saveToLocalStorage({{ camel_case root.name }}.value);
    });

    window.addEventListener('storage', loadFromLocalStorage);
    return { {{ camel_case root.name }}  }
  },
});

{{~ for class in classes ~}}

app.component('{{ kebab_case class.name }}-edit', {
  template: `
  <li class="list-group-item text-start">
    <button type="button" class="btn btn-sm rounded-pill" @click="$emit('delete')">
      <span class="bi bi-trash" aria-hidden="true"></span> Delete
    </button>
  </li>
  {{~ for property in class.common_properties
      if !property.is_key ~}}
  <li class="list-group-item text-start">
    <div class="col-12 d-flex justify-content-start form-floating">
      <input 
      {{~ if (get_type property) == "Date" ~}}
      type="datetime-local"
      {{~ else if (get_type property) == "number" ~}}
      type="number"
      {{~ else ~}}
      type="text"
      {{~ end ~}} 
      class="form-control"
      v-model="editedItem.{{ camel_case property.name }}"
      @input="save"
      placeholder="{{ property.name }}">
      <label for="floatingInput">{{ property.name }}</label>
    </div>
  </li>
  {{~ end
      end ~}}
  `,
  name: '{{ class.name }}Edit',
  props: {
    modelValue: Object,
  },
  emits: ['update:modelValue', 'delete'],
  setup(props, context) {
    const editedItem = reactive({ ...props.modelValue });

    function save() {
      context.emit('update:modelValue', editedItem);
    }

    return { editedItem, save }
  },
});

app.component('{{ kebab_case class.name }}-list', {
  template: `
  <div class="mt-3">
    <div class="d-flex mb-1">
      <h5>{{ class.name.plural }}:</h5>
    </div>
    <!-- If {{ class.name }} has an identifier, then use it instead of idx as key! -->
    <div class="col-12 mb-2" v-for="(item, idx) in modelValue" :key="idx">
      <div class="card shadow-sm">
        <{{ kebab_case class.name }}-edit :modelValue="item" @update:modelValue="updateItem(idx, $event)" @delete="deleteItem(idx)"></{{ kebab_case class.name }}-edit>
      </div>
      {{~ for property in class.properties
          if property.is_collection && property.class ~}}
      <div class="card ms-5 mt-2">
        <{{ kebab_case property.class.name }}-list :modelValue="item.{{ camel_case property.class.name.plural }}" @update:modelValue="update{{ property.class.name.plural }}(idx, $event)"></{{ kebab_case property.class.name }}-list>
      </div>
      {{~ end
          end ~}}
    </div>
    <div class="d-flex">
      <button type="button" class="btn btn-sm rounded-pill mb-1" @click="addNewItem()">
        <span class="bi bi-plus" aria-hidden="true"></span> Add {{ class.name }}
      </button>
    </div>
  </div>`,
  name: '{{ class.name }}List',
  props: {
    modelValue: Array
  },
  emits: ['update:modelValue'],
  setup(props, context) {

    function deleteItem(idx) {
      if (confirm('Are you sure to delete this {{ camel_case (to_words class.name) }}?')) {
        context.emit('update:modelValue', props.modelValue.filter((item, i) => i !== idx));
      }
    }
    function updateItem(idx, item) {
      let newList = [...props.modelValue];
      newList[idx] = item;
      context.emit('update:modelValue', newList);
    }
    {{~ for property in class.properties
        if property.is_collection && property.class ~}}
    function update{{ property.class.name.plural }}(idx, list) {
      let newList = [...props.modelValue];
      newList[idx] = {
        ...newList[idx],
        {{ camel_case property.class.name.plural }}: list
      };
      context.emit('update:modelValue', newList);
    }
    {{~ end
      end ~}}
    function addNewItem() {
      let newItem = {
        {{~ for property in class.properties
            if !property.is_key && !property.is_parent_reference ~}}
        {{ camel_case property.name }}: {{ if property.is_collection }}[]{{else}}''{{end}}{{if !for.last}},{{end}}
        {{~ end
            end ~}}
      };
      saveNewItem(newItem);
    }
    function saveNewItem(item) {
        const items = [...props.modelValue];
        items.push(item);
        context.emit('update:modelValue', items);
    }

    return {
      deleteItem,
      updateItem,
      addNewItem,
      {{~ for property in class.properties
        if property.is_collection && property.class ~}}
      update{{ property.class.name.plural }},
      {{~ end 
      end ~}}
    };
  }
});
{{~ end ~}}

app.mount('#app');
